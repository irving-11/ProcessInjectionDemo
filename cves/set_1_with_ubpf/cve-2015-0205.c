/*
note: "Fix to prevent use of DH client certificates without sending certificate verify message." BY adding conditions.
cve link: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-0205
commit link: https://github.com/openssl/openssl/commit/1421e0c584ae9120ca1b88098f13d6d2e90b83a3
*/

#define _GNU_SOURCE

#include <inttypes.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <errno.h>
#include <elf.h>
#include <math.h>
#include "ubpf_int.h"

#define EVP_PKT_SIGN    0x0010

static int8_t code1[] = ""
"\x61\x12\x00\x00\x00\x00\x00\x00\x61\x11\x04\x00\x00\x00\x00\x00\x67\x01\x00\x00\x20\x00\x00\x00\x4f"
"\x21\x00\x00\x00\x00\x00\x00\xb7\x00\x00\x00\x01\x00\x00\x00\x55\x01\x01\x00\x00\x00\x00\x00\xb7\x00"
"\x00\x00\x00\x00\x00\x00\x95\x00\x00\x00\x00\x00\x00\x00"
"";

typedef struct stack_frame {
	int *a1;
	//uint64_t a2;
	//uint64_t a3;
	//uint64_t a4;
	//uint64_t a5;
	//uint64_t a6;
} __attribute__ ((__packed__, aligned(4))) stack_frame;

struct ptr {
	int *p;
};

uint64_t patch_dispatcher(stack_frame *frame);
void patch_handler();

int orig_c0(int *s) 
{
    int type = 1;
    int *peer;//, value = 11;
    peer = s;

    if ((peer != NULL) && (type & EVP_PKT_SIGN))
        return 1;

    return 0;
}

int run_ebpf(stack_frame *frame)
{
    struct ubpf_vm *vm = ubpf_create();
    if (!vm) {
        fprintf(stderr, "Failed to create VM\n");
        return 1;
    }

    vm->insts = malloc(sizeof(code1));
    if (vm->insts == NULL) {
        return -1;
    }
    memcpy(vm->insts, code1, sizeof(code1));
    vm->num_insts = sizeof(code1)/sizeof(vm->insts[0]);

    uint64_t ret;
    if (ubpf_exec(vm, frame, sizeof(stack_frame), &ret) < 0)
        ret = UINT64_MAX;

    ubpf_destroy(vm);
	return ret;
}

__attribute__((naked))
void patch_handler() {
	__asm__ __volatile__ (
		"push %rbp \n\t"

		// save arguments to stack
		"sub $0x8,%rsp \n\t"
		"mov %rsp,%rbp \n\t"
		"mov %rdi,0x00(%rbp) \n\t"
		//"mov %rsi,0x08(%rbp) \n\t"
		//"mov %rdx,0x10(%rbp) \n\t"

		// patch_dispatcher(stack_pointer)
		"mov %rbp, %rdi \n\t" // arg1 = sp
		"callq patch_dispatcher \n\t"

		// // restore context
		// "mov 0x00(%rbp), %rbx \n\t"
		// "mov 0x08(%rbp), %r12 \n\t"
		// "mov 0x10(%rbp), %r13 \n\t"
		// "mov 0x18(%rbp), %r14 \n\t"
		// "mov 0x20(%rbp), %r15 \n\t"
		// "mov 0x28(%rbp), %rbp \n\t"

		"mov %rbp, %rsp \n\t"
		"add $0x8,%rsp \n\t" // 16 byte aligned
		"pop %rbp \n\t"
		"retq \n\t");
}

uint64_t patch_dispatcher(stack_frame *frame) {
	
    int ret = run_ebpf(frame);
    //printf("%p\n", frame->a1);
	//printf("Argument: a1:%ld a2:%d a3:%d\n", frame->a1, *(int *)(uintptr_t)(frame->a2), *((struct ptr*)(uintptr_t)frame->a3)->p);
	//printf("Argument: a1:%ld a2:%ld a3:%ld\n", frame->a1, frame->a2, frame->a3);
	return ret;
	//return 11;
}

int main() {
	int i = 0;
	int result = 0;
	while(1){
		printf("tick: %d\n", i);
		printf("Demo! [pid:%d]\n", getpid());
		result = orig_c0((int *)11);
		if(result == 1){
			printf("This is New Function\n");
		}else if (result == 0){
			printf("This is Old Function\n");
		}
        //printf("orig_c0(): %d\n", orig_c0((int *)11));

        i++;
        sleep(2);
	}
    
    return 0;
}

// cc -Wall -Werror -Iinc -O2 -g -Wunused-parameter -fPIC   -c -o test.o test.c

// cc   test.o libubpf.a  -lm -o test